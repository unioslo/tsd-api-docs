
# TSD OIDC

TSD OpenID implements the [code flow](https://openid.net/specs/openid-connect-core-1_0.html), along with the [Proof Key for Code Exchange](https://tools.ietf.org/html/rfc7636) extension. The former is available for confidential clients, while the latter is enforced for public clients. All endpoints, documented below, are available at `https://test.api.tsd.usit.no/tsd-oidc-provider`for the test environment and `https://oidc.tsd.usit.no/tsd-oidc-provider` for production.

### /.well-known/openid-configuration

The dynamic configuration endpoint, available [here](https://oidc.tsd.usit.no/tsd-oidc-provider/.well-known/openid-configuration), shows where to obtain the provider's public key `/jwk`, which clients can use for idtoken signature validation. It also shows a host of other provider metadata. To read more about their meaning, refer to [the specification](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).

### /authorize

The code flow starts with the client redirecting the user agent to the `/authorize` endpoint. An example redirect for the code flow, without PKCE, including all mandatory parameters is (with newline formatting just for clarity):

```txt
/authorize?
    response_type=code&
    scope=openid&
    client_id=944b2d25-7871-4c60-91cf-d44d38e918bd&
    redirect_uri=https%3A%2F%2Fmyapp.com%2Fresources%0A&
    nonce=oaBP3Db6tQiLSV1TrDO0PnJ97Msea8FUoV8RZLLl-x8&
    state=6Gy0dPeuO_GYT9Qbx08GP5nXalxPD63apOGJ9K6P71I
```

If the client was registered as a public client, and therefore using PKCE, including the `code_challenge` and `code_challenge_method` would be mandatory:

```txt
/authorize?
    response_type=code&
    scope=openid&
    client_id=944b2d25-7871-4c60-91cf-d44d38e918bd&
    redirect_uri=https%3A%2F%2Fmyapp.com%2Fresources%0A&
    nonce=oaBP3Db6tQiLSV1TrDO0PnJ97Msea8FUoV8RZLLl-x8&
    state=6Gy0dPeuO_GYT9Qbx08GP5nXalxPD63apOGJ9K6P71I
    code_challenge=2b7c122893a57c75a68b38dc3eb13aedc29c39e5aa582db59720afc89dafce10&
    code_challenge_method=S256
```

where the value of the `code_challenge` is a SHA-256 digest of a random session secret genrated by the client.

Supported parameters are:

* `response_type`, _mandatory_, value `code`
* `scope`, _mandatory_, url encoded space separated list, supported scopes:
    * `openid`, _mandatory_
    * `profile`, _optional_, profile information
    * `groups`, _optional_, user group memberships
    * `mods`, _optional_, user group moderations
    * `users`, _optional_, all TSD users
    * `projects`, _optional_, all TSD projects
    * `email`: _optional_, the email of the user
    * `projects-info`, _optional_, which projects the _person_ is affiliated with
* `client_id` _mandatory_, client identifier
* `redirect_uri` _mandatory_, registered redirect URI
* `nonce` _mandatory_, random session value generated by client
    * note: the provider requires entropy greater or equal to that of a UUID
* `state` _mandatory_, random session value generated by client
    * note: the provider requires entropy greater or equal to that of a UUID
* `code_challenge` _mandatory for PKCE_, SHA-256 digest of random value generated by client
* `code_challenge_method` _mandatory for PKCE_, value `S256`
* `acr_values`, _optional_, url encoded space separated list, ordered in preference
    * supported values `level3`, `level1`
    * `level3`, password and OTP is the default
    * `level1`, password only, is only supported inside TSD
* `prompt`, _optional_, accepted values: `login`, `none`, `select_account`, used during SSO
* `max_age`, _optional_, use in combination with `prompt` specifying the maximum amount of minutes which may have elapsed since the previous authentication, TSD enforces a maximum of two hours, clients can choose smaler values
* `id_token_hint`, _optional_, the ID token itself, used during SSO
* `login_hint`, _optional_, the name user account which you want to login, used during SSO

A successful request to `/authorize` will result in the provider prompting the user for authentication. If authentication succeeds, then the provider will redirect back to the provided `redirect_uri`, adding the `state` parameter, and the `code`, to be used in the `/token` request. An example redirect is:

```txt
/resources?
    state=6Gy0dPeuO_GYT9Qbx08GP5nXalxPD63apOGJ9K6P71I&
    code=Xx3jD7Gb9b3THvo0NRJHb132mlm9QmUikHwbrnU9TRk.oaBP3Db6tQiLSV1TrDO0PnJ97Msea8FUoV8RZLLl-x8.YCTnCQ.bEEy9S1Aqtw1TE60vuVgpkUijEI
```

### /token

An example `/token` request, for confidential clients not using PKCE is:

```txt
POST /tsd-oidc-provider/token
Authorization: Basic b64(client_id:client_secret)
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&
code=Xx3jD7Gb9b3THvo0NRJHb132mlm9QmUikHwbrnU9TRk.oaBP3Db6tQiLSV1TrDO0PnJ97Msea8FUoV8RZLLl-x8.YCTnCQ.bEEy9S1Aqtw1TE60vuVgpkUijEI&
redirect_uri=https%3A%2F%2Fmyapp.com%2Fresources%0A&
nonce=oaBP3Db6tQiLSV1TrDO0PnJ97Msea8FUoV8RZLLl-x8
```

Public clients must use PKCE, and omit the `Authorization` header, but include the `code_verifier`:

```txt
POST /tsd-oidc-provider/token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&
code=Xx3jD7Gb9b3THvo0NRJHb132mlm9QmUikHwbrnU9TRk.oaBP3Db6tQiLSV1TrDO0PnJ97Msea8FUoV8RZLLl-x8.YCTnCQ.bEEy9S1Aqtw1TE60vuVgpkUijEI&
redirect_uri=https%3A%2F%2Fmyapp.com%2Fresources%0A&
nonce=oaBP3Db6tQiLSV1TrDO0PnJ97Msea8FUoV8RZLLl-x8&
code_verifier=mysecretvalue
```

The following conditions must hold:

* the request must be made before the code expires
* the `redirect_uri` must be the same as the one used in the `/authorize` request
* the `nonce` must be the same as the one used in the `/authorize` request

It is possible to use the `/token` endpoint with the refresh token (returned as part of the ID token) to obtain a new ID token:

```txt
POST /tsd-oidc-provider/token
Authorization: Basic b64(client_id:client_secret)
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&
refresh_token=eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiI5NDRiMmQyNS03ODcxLTRjNjAtOTFjZi1kNDRkMzhlOTE4YmQiLCJleHAiOjE2MTMwMzI5NzcsImlkIjoicDExLWxlb25jZCJ9.9V4z7GHI27x3avyGtcrxCTpRthHtZgZKhfDKFc-4u4Y&
scope=openid
```

Here it is up to the client to request the scopes they want, while the `openid` scope is compulsory. This will return a new ID token, with a new `nonce`, tied to the same session. If the session has expired, then refresh tokens can no longer be used.


### Single Sign-On (SSO)

SSO is an opt-in feature which is tied to a session maintained by the OIDC provider. This session lasts 2 hours.

If a client performs an authorization request and includes `prompt=login`, then the provider will always authenticate the user, regardless of the status of the user's session.

SSO can be used in the following ways, each of them controlled by sending parameters in the authorization request:

1. `prompt=none` or no `prompt` at all - if there is an active session for the current browser, the user will logged into the TSD account with which they last logged in with.

2. `prompt=select_account&login_hint=p12-test&id_token_hint=<idtoken>` - this is how clients can switch between different TSD accounts without requiring re-authentication _and without any user interaction at the provider_ - it requires that the client cache the latest ID token, and that the ID token contains the `users` claim. This method is suitable for clients which are able to (or want to) implement their own project selection pages.

3. `prompt=select_account` - the provider will display a dialogue allowing the user to choose which project/account they want to use, once the choice is made a new session is stared. If the user only has one account then SSO continue without interation. Clients must have requested both the `users` and `projects` claims in the initial login to use this, otherwise the user will be prompted for login again. This method is suitable for clients which are _not_ able to (or do not want to) implement their own project selection pages.

### idtoken

If the `/token` request is successful, then an `idtoken` is returned, e.g.:

```json
{
    "access_token": "eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiI5NDRiMmQyNS03ODcxLTRjNjAtOTFjZi1kNDRkMzhlOTE4YmQiLCJleHAiOjE2MTMwMzI5NzcsImlkIjoicDExLWxlb25jZCJ9.9V4z7GHI27x3avyGtcrxCTpRthHtZgZKhfDKFc-4u4Y",
    "token_type": "Bearer",
    "refresh_token": "eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiI5NDRiMmQyNS03ODcxLTRjNjAtOTFjZi1kNDRkMzhlOTE4YmQiLCJleHAiOjE2MTMwMzI5NzcsImlkIjoicDExLWxlb25jZCJ9.9V4z7GHI27x3avyGtcrxCTpRthHtZgZKhfDKFc-4u4Y",
    "expires_in": 30,
    "id_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6IkZoSFBTNm90NTNmdnZIM3QtSlV3Vm5hMmVzczNYcUx2dkNuQWl1cWp4dm8ifQ.eyJhY3IiOiJsZXZlbDMiLCJhbXIiOiJUU0QtQXV0aCIsImF1ZCI6Ijk0NGIyZDI1LTc4NzEtNGM2MC05MWNmLWQ0NGQzOGU5MThiZCIsImF1dGhfdGltZSI6MTYxMjk1NDA3OSwiZXhwIjoxNjEzMDMyOTc3LCJpYXQiOjE2MTMwMzExNzcsImlzcyI6Imh0dHA6Ly9sb2NhbGhvc3Q6Mjk5OS92MS9hbGwvdHNkLW9pZGMtcHJvdmlkZXIiLCJub25jZSI6Im9hQlAzRGI2dFFpTFNWMVRyRE8wUG5KOTdNc2VhOEZVb1Y4UlpMTGwteDgiLCJwcm9qIjoicDExIiwic3ViIjoiIiwidXNlciI6InAxMS1sZW9uY2QifQ.ZvsUpnABXswcHcrFWLJFfuUF6Pa7-Rl1gsg2ScjhesU9DU6xvUTQdqFyO97DYWpAtkDBL0Cr9spVcOueObsFJS5vtvvltwk3ZND0-91V0eDbpgOe8rpPgjf_L7ykbSLjXVyLg2NxvBPu0aSlsPW884yyqo37rzg022WNLbqojZUnpZKyP-7_04BFu7zuMd6FONHjEqZFtzOzJFb0gt_U9q_AbQ5WBb3yGmJwNg7NFSkmPBK8OUOomcym90TcFTXvthUzuRr4gooppAC2q48LV_Xr1dRvpqJTpA_jjX4BzVA1qFsharmMDexjyx_8oJdfFCm8X4Lqnocyk00K3jnD3w"
}
```

with attributes as follows:

* `access_token`, a JWT for use at the `/userinfo` endpoint
* `token_type`, which type of token the `access_token` is
* `refresh_token`, a JWT which can be used to fetch a new ID token and the `/token`  endpoint
* `expires_in`, minutes in which the `id_token` expires
* `id_token`, a JWT with the following claims, e.g.:

```json
{
  "acr": "level3",
  "amr": ["password", "totp"],
  "aud": "944b2d25-7871-4c60-91cf-d44d38e918bd",
  "auth_time": 1612954079,
  "exp": 1613032977,
  "email": "lol@cat.meaow",
  "iat": 1613031177,
  "iss": "https://oidc.tsd.usit.no/tsd-oidc-provider",
  "name": "Lol Cat",
  "nonce": "oaBP3Db6tQiLSV1TrDO0PnJ97Msea8FUoV8RZLLl-x8",
  "proj": "p11",
  "projects": ["p11", "p12"],
  "projects-info": {
    "p11": {
      "project_name": "test project",
      "project_start_date": "2014-01-01",
      "project_end_date": "2023-12-12",
      "institution": "uio"
    },
    "p12": {
      "project_name": "ways of undertaking things",
      "project_start_date": "2022-05-01",
      "project_end_date": "2030-01-31",
      "institution": "fhi"
    }
  },
  "sub": "226d4cb4-5e95-40a2-855d-583e5a8930a5",
  "user": "p11-test",
  "users": ["p11-test", "p12-test"]
}
```

The claims are:

* `acr`, Authentication Context Class Reference, or level of assurance
* `amr`, Authentication Methods References, identifies the authentication methods used
* `aud`, the audience, i.e. client_id
* `auth_time`, time when authentication occurred
* `exp`, time when id_token expires
* `iat`, time when idtoken was issued
* `iss`, issuer, i.e. the OpenID Proviider
* `nonce`, random value generated at start of code flow
* `sub`, opaque persistent string identifying the user
* `email`, the user's email address
* `name`, the user's full name

Along with provider specific claim:

* `proj`, which TSD project was authenticated against
* `user`, the user name which was used during authentication
* `users`, all active users, tied to active affiliated projects
* `projects`, list of active projects which the user is affiliated with
* `projects-info`, extended information
  * `project_name`, the short name of the project
  * `project_start_date`, when the project starts
  * `project_end_date`, when the project ends
  * `institution`, the institution responsible for the project

Additional claims are added based on the scopes requested.

### /userinfo

To get additional information about authenticated users, client can make requests to the `/userinfo` endpoint, where specific scopes can be requested. If no scopes are specified the following will be returned by default, in JSON format:

* `sub`
* `user`
* `proj`

Clients can request addition scopes based on what they have been authorized for:

* `users`
* `groups`
* `mods`
* `email`
* `profile`
* `projects`
* `projects-info`

If clients prefer to receive results from the `/userinfo` endpoint as signed JWT instead of JSON, then they can request this from TSD. An example request is:

```txt
GET /tsd-oidc-provider/userinfo
Authorization: Bearer $access_token
```

Clients should use the access token that is returned as a part ID token.

### /end_session

To end a session, thereby preventing any further SSO, client make a `GET` or `POST` request to `/end_session` such as, e.g.:

```txt
/end_session?
  id_token_hint=<the_id_token_which_identifies_the_session>&
  post_logout_redirect_uri=https%3A%2F%2Fmyapp.com%2Flogged_out%0A
  state=6Gy0dPeuO_GYT9Qbx08GP5nXalxPD63apOGJ9K6P71I
```

Clients must register the `post_logout_redirect_uri`s which will be used. Including the `state` is optional.
